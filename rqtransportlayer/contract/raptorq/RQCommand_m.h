//
// Generated file, do not edit! Created by nedtool 5.2 from inet/raptorqimplementation/rqtransportlayer/RaptorQ/queues/../../contract/raptorq/RQCommand.msg.
//

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#ifndef __INET_RQCOMMAND_M_H
#define __INET_RQCOMMAND_M_H

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0502
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif

// cplusplus {{
#include "inet/networklayer/common/L3Address.h"
// }}


namespace inet {

/**
 * Enum generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/queues/../../contract/raptorq/RQCommand.msg:34</tt> by nedtool.
 * <pre>
 * //
 * // RQR command codes, sent by the application to RQR. These constants
 * // should be set as message kind on a message sent to the RQR entity.
 * //
 * // \@see ~RQRCommand, ~RQROpenCommand, ~IRaptorQ
 * //
 * enum RQCommandCode
 * {
 * 
 *     RQ_C_OPEN_ACTIVE = 1;   // active open (must carry ~RQOpenCommand)
 *     RQ_C_OPEN_PASSIVE = 2;  // passive open (must carry ~RQOpenCommand)
 *     RQ_C_SEND = 3;          // send data (set on data packet)
 *     RQ_C_CLOSE = 5;         // "I have no more data to send"
 *     RQ_C_ABORT = 6;         // abort connection
 *     RQ_C_STATUS = 7;        // request status info (RQ_I_STATUS) from RQ
 *     RQ_C_QUEUE_BYTES_LIMIT = 8; // set send queue limit (in bytes)
 *     RQ_C_READ = 9;       // send request to RQ to deliver data
 * }
 * </pre>
 */
enum RQCommandCode {
    RQ_C_OPEN_ACTIVE = 1,
    RQ_C_OPEN_PASSIVE = 2,
    RQ_C_SEND = 3,
    RQ_C_CLOSE = 5,
    RQ_C_ABORT = 6,
    RQ_C_STATUS = 7,
    RQ_C_QUEUE_BYTES_LIMIT = 8,
    RQ_C_READ = 9
};

/**
 * Enum generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/queues/../../contract/raptorq/RQCommand.msg:53</tt> by nedtool.
 * <pre>
 * //
 * // RQ indications, sent by RQ to the application. RQ will set these
 * // constants as message kind on messages it sends to the application.
 * //
 * // \@see ~RQCommand, ~RQStatusInfo, ~IRQ
 * //
 * enum RQStatusInd
 * {
 * 
 *     RQ_I_DATA = 1;              // data packet (set on data packet)
 *     RQ_I_URGENT_DATA = 2;       // urgent data (set on data packet)
 *     RQ_I_ESTABLISHED = 3;       // connection established
 *     RQ_I_PEER_CLOSED = 4;       // FIN received from remote RQ
 *     RQ_I_CLOSED = 5;            // connection closed normally (via FIN exchange)
 *     RQ_I_CONNECTION_REFUSED = 6; // connection refused
 *     RQ_I_CONNECTION_RESET = 7;  // connection reset
 *     RQ_I_TIMED_OUT = 8;         // conn-estab timer went off, or max retransm. count reached
 *     RQ_I_STATUS = 9;            // status info (will carry ~RQStatusInfo)
 *     RQ_I_SEND_MSG = 10;         // send queue abated, send more messages
 *     RQ_I_DATA_NOTIFICATION = 11; // notify the upper layer that data has arrived
 * }
 * </pre>
 */
enum RQStatusInd {
    RQ_I_DATA = 1,
    RQ_I_URGENT_DATA = 2,
    RQ_I_ESTABLISHED = 3,
    RQ_I_PEER_CLOSED = 4,
    RQ_I_CLOSED = 5,
    RQ_I_CONNECTION_REFUSED = 6,
    RQ_I_CONNECTION_RESET = 7,
    RQ_I_TIMED_OUT = 8,
    RQ_I_STATUS = 9,
    RQ_I_SEND_MSG = 10,
    RQ_I_DATA_NOTIFICATION = 11
};

/**
 * Enum generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/queues/../../contract/raptorq/RQCommand.msg:72</tt> by nedtool.
 * <pre>
 * //
 * // Currently not in use.
 * //
 * enum RQErrorCode
 * {
 * 
 * }
 * </pre>
 */
enum RQErrorCode {
};

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/queues/../../contract/raptorq/RQCommand.msg:91</tt> by nedtool.
 * <pre>
 * //
 * // Control info for RQ connections. This class is to be set as control info
 * // (see cMessage::setControlInfo()) on all messages exchanged between RQ and
 * // application, in both directions. Some commands and indications
 * // (RQ_C_OPEN_xxx, RQ_I_STATUS) use subclasses.
 * //
 * // connId identifies the connection locally within the application (internally,
 * // RQ uses the (app gate index, connId) pair to identify the socket).
 * // connId is to be chosen by the application in the open command.
 * //
 * //# TODO explain userId
 * //
 * // \@see ~RQCommandCode, ~RQStatusInd, ~RQOpenCommand, ~RQStatusInfo, ~IRaptorQ
 * //
 * class RQCommand
 * {
 *     int connId = -1;   // identifies the socket within the application
 *     int userId = -1;   // id than can be freely used by the app
 *     bool forcMultiSrcConnClose = false;
 *     int multiSourcingGrpId = -1;
 * 
 * }
 * </pre>
 */
class INET_API RQCommand : public ::omnetpp::cObject
{
  protected:
    int connId;
    int userId;
    bool forcMultiSrcConnClose;
    int multiSourcingGrpId;

  private:
    void copy(const RQCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQCommand&);

  public:
    RQCommand();
    RQCommand(const RQCommand& other);
    virtual ~RQCommand();
    RQCommand& operator=(const RQCommand& other);
    virtual RQCommand *dup() const override {return new RQCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getConnId() const;
    virtual void setConnId(int connId);
    virtual int getUserId() const;
    virtual void setUserId(int userId);
    virtual bool getForcMultiSrcConnClose() const;
    virtual void setForcMultiSrcConnClose(bool forcMultiSrcConnClose);
    virtual int getMultiSourcingGrpId() const;
    virtual void setMultiSourcingGrpId(int multiSourcingGrpId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/queues/../../contract/raptorq/RQCommand.msg:104</tt> by nedtool.
 * <pre>
 * //
 * // Currently not in use.
 * //
 * class RQErrorInfo extends RQCommand
 * {
 *     int errorCode \@enum(RQErrorCode);
 *     string messageText;
 * }
 * </pre>
 */
class INET_API RQErrorInfo : public ::inet::RQCommand
{
  protected:
    int errorCode;
    ::omnetpp::opp_string messageText;

  private:
    void copy(const RQErrorInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQErrorInfo&);

  public:
    RQErrorInfo();
    RQErrorInfo(const RQErrorInfo& other);
    virtual ~RQErrorInfo();
    RQErrorInfo& operator=(const RQErrorInfo& other);
    virtual RQErrorInfo *dup() const override {return new RQErrorInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getErrorCode() const;
    virtual void setErrorCode(int errorCode);
    virtual const char * getMessageText() const;
    virtual void setMessageText(const char * messageText);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQErrorInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQErrorInfo& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/queues/../../contract/raptorq/RQCommand.msg:123</tt> by nedtool.
 * <pre>
 * //
 * // Defines what to transmit as payload in RQ segments
 * //
 * // Currently you have the following choices:
 * //   - RQ_TRANSFER_BYTECOUNT:
 * //      RQ layer will transmit byte counts only.
 * //   - RQ_TRANSFER_OBJECT:
 * //      RQ layer will transmit the copy of application packet C++ objects
 * //   - RQ_TRANSFER_BYTESTREAM:
 * //      RQ layer will transmit bytes of the application packet.
 * //
 * // See ~IRQ (the RQ layer interface) for details.
 * //
 * enum RQDataTransferMode
 * {
 * 
 *     RQ_TRANSFER_UNDEFINED = 0;         // Invalid value
 *     RQ_TRANSFER_BYTECOUNT = 1;         // Transmit byte counts only
 *     RQ_TRANSFER_OBJECT = 2;            // Transmit the application packet C++ objects
 *     RQ_TRANSFER_BYTESTREAM = 3;        // Transmit raw bytes
 *     RQ_REQUESTS = 4;
 *     RQ_RECEIVE_SYMBOLS = 5;
 * }
 * </pre>
 */
enum RQDataTransferMode {
    RQ_TRANSFER_UNDEFINED = 0,
    RQ_TRANSFER_BYTECOUNT = 1,
    RQ_TRANSFER_OBJECT = 2,
    RQ_TRANSFER_BYTESTREAM = 3,
    RQ_REQUESTS = 4,
    RQ_RECEIVE_SYMBOLS = 5
};

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/queues/../../contract/raptorq/RQCommand.msg:159</tt> by nedtool.
 * <pre>
 * //
 * // Control info to be used for active or passive RQ open.
 * //
 * // localAddr, remoteAddr, localPort, remotePort should be self-explanatory.
 * // localAddr is optional because RQ can learn it from IP when a packet
 * // is received from the peer; localPort is optional because RQ supports
 * // ephemeral ports.
 * //
 * // The fork parameter is used with passive open, and controls what happens
 * // when an incoming connection is received. With fork=true, it emulates
 * // the Unix accept(2) syscall semantics: a new connection structure
 * // is created for the connection (with a new connId, see in ~RQCommand),
 * // and the connection structure with the old connId remains listening.
 * // With fork=false, all the above does not happen: the first connection
 * // is accepted (with the original connId), and further incoming connections
 * // will be refused by RQ by sending an RST segment.
 * //
 * // The dataTransferMode and rqAlgorithmClass fields
 * // allow per-connection TCP configuration.
 * // The dataTransferMode field set the
 * // The tcpAlgorithmClass field may contain name of class subclassed from
 * // TCPAlgorithm, respectively.
 * // If not set, module parameters with similar names are used.
 * //
 * // \@see ~RQCommandCode, ~IRaptorQ
 * //
 * class RQOpenCommand extends RQCommand
 * {
 *     L3Address localAddr; // may be left empty
 *     L3Address remoteAddr;// required for active open
 *     int localPort = -1;       // required for passive open
 *     int remotePort = -1;      // required for active open
 *     bool fork = false;        // used only for passive open
 *     int dataTransferMode \@enum(RQDataTransferMode); // whether to transmit C++ objects, real bytes or just byte counts. See ~RQDataTransferMode.
 *     string rqAlgorithmClass; // TCP congestion control algorithm; leave empty for default
 * 
 *     int fileIdToGet;
 *     unsigned int numSymbolsToSend;
 *     bool isLongFlow;
 *     bool isMulticastConn;
 *     unsigned int multicastGroupIndex;
 *     bool isSender;
 * 
 *     bool isMultiSourcingConn;
 *     unsigned int multiSourcingGroupIndex;
 * //    bool forcMultiSrcConnClose;
 * 
 * }
 * </pre>
 */
class INET_API RQOpenCommand : public ::inet::RQCommand
{
  protected:
    L3Address localAddr;
    L3Address remoteAddr;
    int localPort;
    int remotePort;
    bool fork;
    int dataTransferMode;
    ::omnetpp::opp_string rqAlgorithmClass;
    int fileIdToGet;
    unsigned int numSymbolsToSend;
    bool isLongFlow;
    bool isMulticastConn;
    unsigned int multicastGroupIndex;
    bool isSender;
    bool isMultiSourcingConn;
    unsigned int multiSourcingGroupIndex;

  private:
    void copy(const RQOpenCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQOpenCommand&);

  public:
    RQOpenCommand();
    RQOpenCommand(const RQOpenCommand& other);
    virtual ~RQOpenCommand();
    RQOpenCommand& operator=(const RQOpenCommand& other);
    virtual RQOpenCommand *dup() const override {return new RQOpenCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual L3Address& getLocalAddr();
    virtual const L3Address& getLocalAddr() const {return const_cast<RQOpenCommand*>(this)->getLocalAddr();}
    virtual void setLocalAddr(const L3Address& localAddr);
    virtual L3Address& getRemoteAddr();
    virtual const L3Address& getRemoteAddr() const {return const_cast<RQOpenCommand*>(this)->getRemoteAddr();}
    virtual void setRemoteAddr(const L3Address& remoteAddr);
    virtual int getLocalPort() const;
    virtual void setLocalPort(int localPort);
    virtual int getRemotePort() const;
    virtual void setRemotePort(int remotePort);
    virtual bool getFork() const;
    virtual void setFork(bool fork);
    virtual int getDataTransferMode() const;
    virtual void setDataTransferMode(int dataTransferMode);
    virtual const char * getRqAlgorithmClass() const;
    virtual void setRqAlgorithmClass(const char * rqAlgorithmClass);
    virtual int getFileIdToGet() const;
    virtual void setFileIdToGet(int fileIdToGet);
    virtual unsigned int getNumSymbolsToSend() const;
    virtual void setNumSymbolsToSend(unsigned int numSymbolsToSend);
    virtual bool getIsLongFlow() const;
    virtual void setIsLongFlow(bool isLongFlow);
    virtual bool getIsMulticastConn() const;
    virtual void setIsMulticastConn(bool isMulticastConn);
    virtual unsigned int getMulticastGroupIndex() const;
    virtual void setMulticastGroupIndex(unsigned int multicastGroupIndex);
    virtual bool getIsSender() const;
    virtual void setIsSender(bool isSender);
    virtual bool getIsMultiSourcingConn() const;
    virtual void setIsMultiSourcingConn(bool isMultiSourcingConn);
    virtual unsigned int getMultiSourcingGroupIndex() const;
    virtual void setMultiSourcingGroupIndex(unsigned int multiSourcingGroupIndex);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQOpenCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQOpenCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/queues/../../contract/raptorq/RQCommand.msg:188</tt> by nedtool.
 * <pre>
 * //
 * // Control info to be used with the SEND command.
 * //
 * // \@see ~RQCommandCode, ~IRaptorQ
 * //
 * class RQSendCommand extends RQCommand
 * {
 * }
 * </pre>
 */
class INET_API RQSendCommand : public ::inet::RQCommand
{
  protected:

  private:
    void copy(const RQSendCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQSendCommand&);

  public:
    RQSendCommand();
    RQSendCommand(const RQSendCommand& other);
    virtual ~RQSendCommand();
    RQSendCommand& operator=(const RQSendCommand& other);
    virtual RQSendCommand *dup() const override {return new RQSendCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQSendCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQSendCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/queues/../../contract/raptorq/RQCommand.msg:199</tt> by nedtool.
 * <pre>
 * //
 * // Sent with message kind RQ_I_ESTABLISHED, to let the app know
 * // about the local and remote IP address and port.
 * //
 * // \@see ~RQCommandCode, ~IRaptorQ
 * //
 * class RQConnectInfo extends RQCommand
 * {
 *     L3Address localAddr;
 *     L3Address remoteAddr;
 *     int localPort;
 *     int remotePort;
 * }
 * </pre>
 */
class INET_API RQConnectInfo : public ::inet::RQCommand
{
  protected:
    L3Address localAddr;
    L3Address remoteAddr;
    int localPort;
    int remotePort;

  private:
    void copy(const RQConnectInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQConnectInfo&);

  public:
    RQConnectInfo();
    RQConnectInfo(const RQConnectInfo& other);
    virtual ~RQConnectInfo();
    RQConnectInfo& operator=(const RQConnectInfo& other);
    virtual RQConnectInfo *dup() const override {return new RQConnectInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual L3Address& getLocalAddr();
    virtual const L3Address& getLocalAddr() const {return const_cast<RQConnectInfo*>(this)->getLocalAddr();}
    virtual void setLocalAddr(const L3Address& localAddr);
    virtual L3Address& getRemoteAddr();
    virtual const L3Address& getRemoteAddr() const {return const_cast<RQConnectInfo*>(this)->getRemoteAddr();}
    virtual void setRemoteAddr(const L3Address& remoteAddr);
    virtual int getLocalPort() const;
    virtual void setLocalPort(int localPort);
    virtual int getRemotePort() const;
    virtual void setRemotePort(int remotePort);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQConnectInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQConnectInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/queues/../../contract/raptorq/RQCommand.msg:215</tt> by nedtool.
 * <pre>
 * //
 * // Sent with message kind RQ_I_STATUS, in response to command RQ_C_STATUS.
 * // For explanation of variables, see RFC 793 or RQStateVariables in
 * // RQConnection.h.
 * //
 * // \@see ~RQStatusInd, ~RQCommandCode, ~IRaptorQ
 * //
 * class RQStatusInfo extends RQCommand
 * {
 *     int state;
 *     string stateName;
 * 
 *     L3Address localAddr;
 *     L3Address remoteAddr;
 *     int localPort;
 *     int remotePort;
 * 
 *     unsigned int snd_mss;
 * 
 *     unsigned int snd_una;
 *     unsigned int snd_nxt;
 *     unsigned int snd_max;
 *     unsigned int snd_wnd;
 *     unsigned int snd_up;
 *     unsigned int snd_wl1;
 *     unsigned int snd_wl2;
 *     unsigned int iss;
 * 
 *     unsigned int rcv_nxt;
 *     unsigned int rcv_wnd;
 *     unsigned int rcv_up;
 *     unsigned int irs;
 * 
 *     bool fin_ack_rcvd;
 * }
 * </pre>
 */
class INET_API RQStatusInfo : public ::inet::RQCommand
{
  protected:
    int state;
    ::omnetpp::opp_string stateName;
    L3Address localAddr;
    L3Address remoteAddr;
    int localPort;
    int remotePort;
    unsigned int snd_mss;
    unsigned int snd_una;
    unsigned int snd_nxt;
    unsigned int snd_max;
    unsigned int snd_wnd;
    unsigned int snd_up;
    unsigned int snd_wl1;
    unsigned int snd_wl2;
    unsigned int iss;
    unsigned int rcv_nxt;
    unsigned int rcv_wnd;
    unsigned int rcv_up;
    unsigned int irs;
    bool fin_ack_rcvd;

  private:
    void copy(const RQStatusInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQStatusInfo&);

  public:
    RQStatusInfo();
    RQStatusInfo(const RQStatusInfo& other);
    virtual ~RQStatusInfo();
    RQStatusInfo& operator=(const RQStatusInfo& other);
    virtual RQStatusInfo *dup() const override {return new RQStatusInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getState() const;
    virtual void setState(int state);
    virtual const char * getStateName() const;
    virtual void setStateName(const char * stateName);
    virtual L3Address& getLocalAddr();
    virtual const L3Address& getLocalAddr() const {return const_cast<RQStatusInfo*>(this)->getLocalAddr();}
    virtual void setLocalAddr(const L3Address& localAddr);
    virtual L3Address& getRemoteAddr();
    virtual const L3Address& getRemoteAddr() const {return const_cast<RQStatusInfo*>(this)->getRemoteAddr();}
    virtual void setRemoteAddr(const L3Address& remoteAddr);
    virtual int getLocalPort() const;
    virtual void setLocalPort(int localPort);
    virtual int getRemotePort() const;
    virtual void setRemotePort(int remotePort);
    virtual unsigned int getSnd_mss() const;
    virtual void setSnd_mss(unsigned int snd_mss);
    virtual unsigned int getSnd_una() const;
    virtual void setSnd_una(unsigned int snd_una);
    virtual unsigned int getSnd_nxt() const;
    virtual void setSnd_nxt(unsigned int snd_nxt);
    virtual unsigned int getSnd_max() const;
    virtual void setSnd_max(unsigned int snd_max);
    virtual unsigned int getSnd_wnd() const;
    virtual void setSnd_wnd(unsigned int snd_wnd);
    virtual unsigned int getSnd_up() const;
    virtual void setSnd_up(unsigned int snd_up);
    virtual unsigned int getSnd_wl1() const;
    virtual void setSnd_wl1(unsigned int snd_wl1);
    virtual unsigned int getSnd_wl2() const;
    virtual void setSnd_wl2(unsigned int snd_wl2);
    virtual unsigned int getIss() const;
    virtual void setIss(unsigned int iss);
    virtual unsigned int getRcv_nxt() const;
    virtual void setRcv_nxt(unsigned int rcv_nxt);
    virtual unsigned int getRcv_wnd() const;
    virtual void setRcv_wnd(unsigned int rcv_wnd);
    virtual unsigned int getRcv_up() const;
    virtual void setRcv_up(unsigned int rcv_up);
    virtual unsigned int getIrs() const;
    virtual void setIrs(unsigned int irs);
    virtual bool getFin_ack_rcvd() const;
    virtual void setFin_ack_rcvd(bool fin_ack_rcvd);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQStatusInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQStatusInfo& obj) {obj.parsimUnpack(b);}

} // namespace inet

#endif // ifndef __INET_RQCOMMAND_M_H

