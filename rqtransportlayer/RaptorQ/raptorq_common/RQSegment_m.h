//
// Generated file, do not edit! Created by nedtool 5.2 from inet/raptorqimplementation/rqtransportlayer/RaptorQ/raptorq_common/RQSegment.msg.
//

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#ifndef __INET__RAPTORQ_RQSEGMENT_M_H
#define __INET__RAPTORQ_RQSEGMENT_M_H

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0502
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif

// cplusplus {{
#include <iostream>
#include "inet/common/INETDefs.h"
#include "inet/common/ByteArray.h"

namespace inet {
namespace raptorq {
class Sack;
class RQOption;
typedef RQOption *RQOptionPtr;
}
}
// }}


namespace inet {
namespace raptorq {

// cplusplus {{
    // default RQ header length: 20 bytes
    #define RQ_HEADER_OCTETS  20    // without options

    // maximum RQ header length (base + options): 60 = 4 * 15 bytes
    const unsigned int RQ_MAX_HEADER_OCTETS = 60;

    // maximum allowed sack entry number, if no other options are used
    const unsigned int MAX_SACK_ENTRIES = 4;

    typedef cPacket *cPacketPtr;

    inline std::ostream& operator<<(std::ostream& os, cPacketPtr msg)
    {
        return os << "(" << msg->getClassName() << ") " << msg->getName() << ": " << msg->info();
    }

    inline void doPacking(cCommBuffer *b, cPacketPtr& msg) {msg->parsimPack(b);}
    inline void doUnpacking(cCommBuffer *b, cPacketPtr& msg) {msg->parsimUnpack(b);}
// }}

/**
 * Struct generated from inet/raptorqimplementation/rqtransportlayer/RaptorQ/raptorq_common/RQSegment.msg:45 by nedtool.
 */
struct INET_API RQPayloadMessage
{
    RQPayloadMessage();
    unsigned int endSequenceNo;
    cPacketPtr msg;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const RQPayloadMessage& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, RQPayloadMessage& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQPayloadMessage& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQPayloadMessage& obj) { __doUnpacking(b, obj); }

/**
 * Enum generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/raptorq_common/RQSegment.msg:58</tt> by nedtool.
 * <pre>
 * //
 * // RQ Option Numbers
 * // Reference: http://www.iana.org/assignments/tcp-parameters/
 * // Date: 2011-07-02
 * //
 * // Note: Options not yet implemented should stay commented out
 * //
 * enum RQOptionNumbers
 * {
 * 
 *     RQOPTION_END_OF_OPTION_LIST = 0;                   // RFC 793, LENGTH: 1 Byte
 *     RQOPTION_NO_OPERATION = 1;                         // RFC 793, LENGTH: 1 Byte
 *     RQOPTION_MAXIMUM_SEGMENT_SIZE = 2;                 // RFC 793, LENGTH: 4 Bytes
 *     RQOPTION_WINDOW_SCALE = 3;                         // RFC 1323, LENGTH: 3 Bytes
 *     RQOPTION_SACK_PERMITTED = 4;                       // RFC 2018, LENGTH: 2 Bytes
 *     RQOPTION_SACK = 5;                                 // RFC 2018, LENGTH: N (max. N = 4) 8 * n + 2 Bytes  => 32 + 2 + 2 * NOP = 36 Bytes; If TIMESTAMP option is used with SACK: max. n = 3 => 12 Bytes (for Timestamp) + 28 Bytes (for SACK) = 40 Bytes
 *     //    RQOPTION_ECHO = 6;                               // (obsoleted by option 8) RFC 1072 & RFC 6247, LENGTH: 6 Bytes
 *     //    RQOPTION_ECHO_REPLY = 7;                         // (obsoleted by option 8) RFC 1072 & RFC 6247, LENGTH: 6 Bytes
 *     RQOPTION_TIMESTAMP = 8;                            // RFC 1323, LENGTH: 10 Bytes
 * }
 * </pre>
 */
enum RQOptionNumbers {
    RQOPTION_END_OF_OPTION_LIST = 0,
    RQOPTION_NO_OPERATION = 1,
    RQOPTION_MAXIMUM_SEGMENT_SIZE = 2,
    RQOPTION_WINDOW_SCALE = 3,
    RQOPTION_SACK_PERMITTED = 4,
    RQOPTION_SACK = 5,
    RQOPTION_TIMESTAMP = 8
};

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/raptorq_common/RQSegment.msg:98</tt> by nedtool.
 * <pre>
 * //
 * // This structure represents a single SACK (selective acknowledgment):
 * //
 * class SackItem
 * {
 *     \@fieldNameSuffix("_var"); //TODO remove when OMNeT++ 4.x compatibility is no longer required
 *     unsigned int start;     // start seq no. of sack block
 *     unsigned int end;       // end seq no. of sack block
 * }
 * </pre>
 */
class INET_API SackItem : public ::omnetpp::cObject
{
  protected:
    unsigned int start_var;
    unsigned int end_var;

  private:
    void copy(const SackItem& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SackItem&);

  public:
    SackItem();
    SackItem(const SackItem& other);
    virtual ~SackItem();
    SackItem& operator=(const SackItem& other);
    virtual SackItem *dup() const override {return new SackItem(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned int getStart() const;
    virtual void setStart(unsigned int start);
    virtual unsigned int getEnd() const;
    virtual void setEnd(unsigned int end);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SackItem& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SackItem& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/raptorq_common/RQSegment.msg:105</tt> by nedtool.
 * <pre>
 * class Sack extends SackItem
 * {
 *     \@customize(true);
 * }
 * </pre>
 *
 * Sack_Base is only useful if it gets subclassed, and Sack is derived from it.
 * The minimum code to be written for Sack is the following:
 *
 * <pre>
 * class INET_API Sack : public Sack_Base
 * {
 *   private:
 *     void copy(const Sack& other) { ... }

 *   public:
 *     Sack() : Sack_Base() {}
 *     Sack(const Sack& other) : Sack_Base(other) {copy(other);}
 *     Sack& operator=(const Sack& other) {if (this==&other) return *this; Sack_Base::operator=(other); copy(other); return *this;}
 *     virtual Sack *dup() const override {return new Sack(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from Sack_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(Sack)
 * </pre>
 */
class INET_API Sack_Base : public ::inet::raptorq::SackItem
{
  protected:

  private:
    void copy(const Sack_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Sack_Base&);
    // make constructors protected to avoid instantiation
    Sack_Base();
    Sack_Base(const Sack_Base& other);
    // make assignment operator protected to force the user override it
    Sack_Base& operator=(const Sack_Base& other);

  public:
    virtual ~Sack_Base();
    virtual Sack_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class Sack");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/raptorq_common/RQSegment.msg:112</tt> by nedtool.
 * <pre>
 * class RQOption
 * {
 *     unsigned short kind \@enum(RQOptionNumbers) = -1;  // option kind
 *     unsigned short length = 1;                    // option length
 * }
 * </pre>
 */
class INET_API RQOption : public ::omnetpp::cObject
{
  protected:
    unsigned short kind;
    unsigned short length;

  private:
    void copy(const RQOption& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQOption&);

  public:
    RQOption();
    RQOption(const RQOption& other);
    virtual ~RQOption();
    RQOption& operator=(const RQOption& other);
    virtual RQOption *dup() const override {return new RQOption(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getKind() const;
    virtual void setKind(unsigned short kind);
    virtual unsigned short getLength() const;
    virtual void setLength(unsigned short length);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQOption& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQOption& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/raptorq_common/RQSegment.msg:118</tt> by nedtool.
 * <pre>
 * class RQOptionEnd extends RQOption
 * {
 *     kind = RQOPTION_END_OF_OPTION_LIST;
 *     length = 1;
 * }
 * </pre>
 */
class INET_API RQOptionEnd : public ::inet::raptorq::RQOption
{
  protected:

  private:
    void copy(const RQOptionEnd& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQOptionEnd&);

  public:
    RQOptionEnd();
    RQOptionEnd(const RQOptionEnd& other);
    virtual ~RQOptionEnd();
    RQOptionEnd& operator=(const RQOptionEnd& other);
    virtual RQOptionEnd *dup() const override {return new RQOptionEnd(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQOptionEnd& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQOptionEnd& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/raptorq_common/RQSegment.msg:124</tt> by nedtool.
 * <pre>
 * class RQOptionNop extends RQOption
 * {
 *     kind = RQOPTION_NO_OPERATION;
 *     length = 1;
 * }
 * </pre>
 */
class INET_API RQOptionNop : public ::inet::raptorq::RQOption
{
  protected:

  private:
    void copy(const RQOptionNop& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQOptionNop&);

  public:
    RQOptionNop();
    RQOptionNop(const RQOptionNop& other);
    virtual ~RQOptionNop();
    RQOptionNop& operator=(const RQOptionNop& other);
    virtual RQOptionNop *dup() const override {return new RQOptionNop(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQOptionNop& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQOptionNop& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/raptorq_common/RQSegment.msg:130</tt> by nedtool.
 * <pre>
 * class RQOptionMaxSegmentSize extends RQOption
 * {
 *     kind = RQOPTION_MAXIMUM_SEGMENT_SIZE;
 *     length = 4;
 *     uint16_t maxSegmentSize;   // uint16_t
 * }
 * </pre>
 */
class INET_API RQOptionMaxSegmentSize : public ::inet::raptorq::RQOption
{
  protected:
    uint16_t maxSegmentSize;

  private:
    void copy(const RQOptionMaxSegmentSize& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQOptionMaxSegmentSize&);

  public:
    RQOptionMaxSegmentSize();
    RQOptionMaxSegmentSize(const RQOptionMaxSegmentSize& other);
    virtual ~RQOptionMaxSegmentSize();
    RQOptionMaxSegmentSize& operator=(const RQOptionMaxSegmentSize& other);
    virtual RQOptionMaxSegmentSize *dup() const override {return new RQOptionMaxSegmentSize(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint16_t getMaxSegmentSize() const;
    virtual void setMaxSegmentSize(uint16_t maxSegmentSize);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQOptionMaxSegmentSize& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQOptionMaxSegmentSize& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/raptorq_common/RQSegment.msg:137</tt> by nedtool.
 * <pre>
 * class RQOptionWindowScale extends RQOption
 * {
 *     kind = RQOPTION_WINDOW_SCALE;
 *     length = 3;
 *     unsigned short windowScale;   // uint8_t
 * }
 * </pre>
 */
class INET_API RQOptionWindowScale : public ::inet::raptorq::RQOption
{
  protected:
    unsigned short windowScale;

  private:
    void copy(const RQOptionWindowScale& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQOptionWindowScale&);

  public:
    RQOptionWindowScale();
    RQOptionWindowScale(const RQOptionWindowScale& other);
    virtual ~RQOptionWindowScale();
    RQOptionWindowScale& operator=(const RQOptionWindowScale& other);
    virtual RQOptionWindowScale *dup() const override {return new RQOptionWindowScale(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getWindowScale() const;
    virtual void setWindowScale(unsigned short windowScale);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQOptionWindowScale& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQOptionWindowScale& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/raptorq_common/RQSegment.msg:144</tt> by nedtool.
 * <pre>
 * class RQOptionSackPermitted extends RQOption
 * {
 *     kind = RQOPTION_SACK_PERMITTED;
 *     length = 2;
 * }
 * </pre>
 */
class INET_API RQOptionSackPermitted : public ::inet::raptorq::RQOption
{
  protected:

  private:
    void copy(const RQOptionSackPermitted& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQOptionSackPermitted&);

  public:
    RQOptionSackPermitted();
    RQOptionSackPermitted(const RQOptionSackPermitted& other);
    virtual ~RQOptionSackPermitted();
    RQOptionSackPermitted& operator=(const RQOptionSackPermitted& other);
    virtual RQOptionSackPermitted *dup() const override {return new RQOptionSackPermitted(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQOptionSackPermitted& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQOptionSackPermitted& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/raptorq_common/RQSegment.msg:150</tt> by nedtool.
 * <pre>
 * class RQOptionSack extends RQOption
 * {
 *     kind = RQOPTION_SACK;
 *     length = 2;     // 2 + getSackArraySize() * 8
 *     SackItem sackItem[];
 * }
 * </pre>
 */
class INET_API RQOptionSack : public ::inet::raptorq::RQOption
{
  protected:
    SackItem *sackItem; // array ptr
    unsigned int sackItem_arraysize;

  private:
    void copy(const RQOptionSack& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQOptionSack&);

  public:
    RQOptionSack();
    RQOptionSack(const RQOptionSack& other);
    virtual ~RQOptionSack();
    RQOptionSack& operator=(const RQOptionSack& other);
    virtual RQOptionSack *dup() const override {return new RQOptionSack(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setSackItemArraySize(unsigned int size);
    virtual unsigned int getSackItemArraySize() const;
    virtual SackItem& getSackItem(unsigned int k);
    virtual const SackItem& getSackItem(unsigned int k) const {return const_cast<RQOptionSack*>(this)->getSackItem(k);}
    virtual void setSackItem(unsigned int k, const SackItem& sackItem);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQOptionSack& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQOptionSack& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/raptorq_common/RQSegment.msg:157</tt> by nedtool.
 * <pre>
 * class RQOptionTimestamp extends RQOption
 * {
 *     kind = RQOPTION_TIMESTAMP;
 *     length = 10;
 *     uint32_t senderTimestamp;
 *     uint32_t echoedTimestamp;
 * }
 * </pre>
 */
class INET_API RQOptionTimestamp : public ::inet::raptorq::RQOption
{
  protected:
    uint32_t senderTimestamp;
    uint32_t echoedTimestamp;

  private:
    void copy(const RQOptionTimestamp& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQOptionTimestamp&);

  public:
    RQOptionTimestamp();
    RQOptionTimestamp(const RQOptionTimestamp& other);
    virtual ~RQOptionTimestamp();
    RQOptionTimestamp& operator=(const RQOptionTimestamp& other);
    virtual RQOptionTimestamp *dup() const override {return new RQOptionTimestamp(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSenderTimestamp() const;
    virtual void setSenderTimestamp(uint32_t senderTimestamp);
    virtual uint32_t getEchoedTimestamp() const;
    virtual void setEchoedTimestamp(uint32_t echoedTimestamp);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQOptionTimestamp& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQOptionTimestamp& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/raptorq_common/RQSegment.msg:165</tt> by nedtool.
 * <pre>
 * class RQOptionUnknown extends RQOption
 * {
 *     kind = -1;
 *     uint8_t bytes[];
 * }
 * </pre>
 */
class INET_API RQOptionUnknown : public ::inet::raptorq::RQOption
{
  protected:
    uint8_t *bytes; // array ptr
    unsigned int bytes_arraysize;

  private:
    void copy(const RQOptionUnknown& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQOptionUnknown&);

  public:
    RQOptionUnknown();
    RQOptionUnknown(const RQOptionUnknown& other);
    virtual ~RQOptionUnknown();
    RQOptionUnknown& operator=(const RQOptionUnknown& other);
    virtual RQOptionUnknown *dup() const override {return new RQOptionUnknown(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setBytesArraySize(unsigned int size);
    virtual unsigned int getBytesArraySize() const;
    virtual uint8_t getBytes(unsigned int k) const;
    virtual void setBytes(unsigned int k, uint8_t bytes);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RQOptionUnknown& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RQOptionUnknown& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/raptorqimplementation/rqtransportlayer/RaptorQ/raptorq_common/RQSegment.msg:185</tt> by nedtool.
 * <pre>
 * //
 * // Represents a RQ segment, to be used with the ~RQ module.
 * //
 * // RQ header fields not explicitly modelled: work on going
 * // - Data Offset (number of 32 bit words in the header): represented
 * //   by cMessage::length().
 * // - Reserved (reserved for future use)
 * // - Checksum (header checksum): modelled by cMessage::hasBitError()
 * // - Header Options: Currently only EOL, NOP, MSS, WS, SACK_PERMITTED, SACK and TS are implemented
 * // - Padding
 * //
 * // cMessage::getKind() may be set to an arbitrary value: RQ entities will
 * // ignore it and use only the header fields (synBit, ackBit, rstBit).
 * //
 * packet RQSegment
 * {
 *     \@customize(true);
 *     \@fieldNameSuffix("_var"); //TODO remove when OMNeT++ 4.x compatibility is no longer required
 * 
 *     // Source Port
 *     unsigned short srcPort;
 * 
 *     // Destination Port
 *     unsigned short destPort;
 * 
 *     // Sequence Number: first sequence number of the first data octet
 *     // in the respective segment (except if SYN is set; then the the
 *     // seq. number is the initial seq. number (ISS) and the first data
 *     // octet is ISS + 1)
 *     unsigned int sequenceNo;
 * 
 *     // Acknowledgement Number: if ACK flag is set, this field contains
 *     // the next sequence number the sender of this segment is expecting
 *     // to receive
 *     unsigned int ackNo;
 * 
 *     // Added MOH
 *     bool isClient;
 *     bool isWriter;
 *     bool isReader;
 *     bool isHeader;
 *     bool isRequestPacket;
 * 
 *     bool isMulticastConnSeg;
 *     unsigned int multicastGroupIndex;
 *     bool isMulticastSender;
 *     bool isMulticastReceiver;
 * 
 *     bool isMultiSourcingConn;
 *     unsigned int multiSourcingGroupIndex;
 *     bool isMultiSourcingSender;
 *     bool isMultiSourcingReceiver;
 * 
 * 
 *     bool isLastSymbolToSend;
 * 
 * 
 *     unsigned int numSymbolsToSend;
 *     unsigned int numSymbolsToGet;
 * 
 *     unsigned int fileId;
 *     unsigned int requestSequenceNumber;
 *     unsigned int symbolSequenceNumber;
 *     unsigned int opcode;
 * 
 * 
 *     // RQ Header Length - default: 20 bytes
 *     // if header options are used the headerLength is greater than 20 bytes (default)
 *     unsigned short headerLength = RQ_HEADER_OCTETS; // RQ_HEADER_OCTETS = 20
 * 
 *     bool urgBit; // URG: urgent pointer field significant if set
 *     bool ackBit; // ACK: ackNo significant if set
 *     bool pshBit; // PSH: push function
 *     bool rstBit; // RST: reset the connection
 *     bool synBit; // SYN: synchronize seq. numbers
 *     bool finBit; // FIN: finish - no more data from sender
 * 
 *     // Window Size: the number of data octets beginning with the one indicated
 *     // in the acknowledgement field which the sender of this segment is
 *     // willing to accept
 *     unsigned short window;
 * 
 *     // Urgent Pointer: communicates the current value of the urgent pointer
 *     // as a positive offset from the sequence number in this segment. The
 *     // urgent pointer points to the sequence number of the octet following
 *     // the urgent data. This field is only be interpreted in segments with
 *     // the URG control bit set.
 *     unsigned short urgentPointer;
 * 
 *     // Header options (optional)
 *     // Currently only EOL, NOP, MSS, WS, SACK_PERMITTED, SACK and TS are implemented
 *     abstract RQOptionPtr headerOption[];
 * 
 *     // Payload length in octets (not an actual RQ header field).
 *     // This may not always be the same as encapsulatedPacket()->getByteLength();
 *     // e.g. when simulating a virtual data stream there's no encapsulated
 *     // packet at all.
 *     unsigned long payloadLength;
 * 
 *     // Message objects (cMessages) that travel in this segment as data.
 *     // This field is used only when the ~RQDataTransferMode is RQ_TRANSFER_OBJECT.
 *     // Every message object is put into the RQSegment that would (in real life)
 *     // carry its first octet. That is, if message object 'msg' with length=100 bytes
 *     // occupies stream offset number range 10000..10099, it will travel in the
 *     // RQSegment which carries the octet 10000. This way it is easily achieved
 *     // that the receiving RQ passes up the message object to its client
 *     // when the last byte of the message has arrived.
 *     abstract RQPayloadMessage payload[];
 * 
 *     // Message bytes that travel in this segment as data.
 *     // This field is used only when the ~RQDataTransferMode is RQ_TRANSFER_BYTESTREAM.
 *     ByteArray byteArray;
 * }
 * </pre>
 *
 * RQSegment_Base is only useful if it gets subclassed, and RQSegment is derived from it.
 * The minimum code to be written for RQSegment is the following:
 *
 * <pre>
 * class INET_API RQSegment : public RQSegment_Base
 * {
 *   private:
 *     void copy(const RQSegment& other) { ... }

 *   public:
 *     RQSegment(const char *name=nullptr, short kind=0) : RQSegment_Base(name,kind) {}
 *     RQSegment(const RQSegment& other) : RQSegment_Base(other) {copy(other);}
 *     RQSegment& operator=(const RQSegment& other) {if (this==&other) return *this; RQSegment_Base::operator=(other); copy(other); return *this;}
 *     virtual RQSegment *dup() const override {return new RQSegment(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from RQSegment_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(RQSegment)
 * </pre>
 */
class INET_API RQSegment_Base : public ::omnetpp::cPacket
{
  protected:
    unsigned short srcPort_var;
    unsigned short destPort_var;
    unsigned int sequenceNo_var;
    unsigned int ackNo_var;
    bool isClient_var;
    bool isWriter_var;
    bool isReader_var;
    bool isHeader_var;
    bool isRequestPacket_var;
    bool isMulticastConnSeg_var;
    unsigned int multicastGroupIndex_var;
    bool isMulticastSender_var;
    bool isMulticastReceiver_var;
    bool isMultiSourcingConn_var;
    unsigned int multiSourcingGroupIndex_var;
    bool isMultiSourcingSender_var;
    bool isMultiSourcingReceiver_var;
    bool isLastSymbolToSend_var;
    unsigned int numSymbolsToSend_var;
    unsigned int numSymbolsToGet_var;
    unsigned int fileId_var;
    unsigned int requestSequenceNumber_var;
    unsigned int symbolSequenceNumber_var;
    unsigned int opcode_var;
    unsigned short headerLength_var;
    bool urgBit_var;
    bool ackBit_var;
    bool pshBit_var;
    bool rstBit_var;
    bool synBit_var;
    bool finBit_var;
    unsigned short window_var;
    unsigned short urgentPointer_var;
    unsigned long payloadLength_var;
    ByteArray byteArray_var;

  private:
    void copy(const RQSegment_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RQSegment_Base&);
    // make constructors protected to avoid instantiation
    RQSegment_Base(const char *name=nullptr, short kind=0);
    RQSegment_Base(const RQSegment_Base& other);
    // make assignment operator protected to force the user override it
    RQSegment_Base& operator=(const RQSegment_Base& other);

  public:
    virtual ~RQSegment_Base();
    virtual RQSegment_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class RQSegment");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getSrcPort() const;
    virtual void setSrcPort(unsigned short srcPort);
    virtual unsigned short getDestPort() const;
    virtual void setDestPort(unsigned short destPort);
    virtual unsigned int getSequenceNo() const;
    virtual void setSequenceNo(unsigned int sequenceNo);
    virtual unsigned int getAckNo() const;
    virtual void setAckNo(unsigned int ackNo);
    virtual bool getIsClient() const;
    virtual void setIsClient(bool isClient);
    virtual bool getIsWriter() const;
    virtual void setIsWriter(bool isWriter);
    virtual bool getIsReader() const;
    virtual void setIsReader(bool isReader);
    virtual bool getIsHeader() const;
    virtual void setIsHeader(bool isHeader);
    virtual bool getIsRequestPacket() const;
    virtual void setIsRequestPacket(bool isRequestPacket);
    virtual bool getIsMulticastConnSeg() const;
    virtual void setIsMulticastConnSeg(bool isMulticastConnSeg);
    virtual unsigned int getMulticastGroupIndex() const;
    virtual void setMulticastGroupIndex(unsigned int multicastGroupIndex);
    virtual bool getIsMulticastSender() const;
    virtual void setIsMulticastSender(bool isMulticastSender);
    virtual bool getIsMulticastReceiver() const;
    virtual void setIsMulticastReceiver(bool isMulticastReceiver);
    virtual bool getIsMultiSourcingConn() const;
    virtual void setIsMultiSourcingConn(bool isMultiSourcingConn);
    virtual unsigned int getMultiSourcingGroupIndex() const;
    virtual void setMultiSourcingGroupIndex(unsigned int multiSourcingGroupIndex);
    virtual bool getIsMultiSourcingSender() const;
    virtual void setIsMultiSourcingSender(bool isMultiSourcingSender);
    virtual bool getIsMultiSourcingReceiver() const;
    virtual void setIsMultiSourcingReceiver(bool isMultiSourcingReceiver);
    virtual bool getIsLastSymbolToSend() const;
    virtual void setIsLastSymbolToSend(bool isLastSymbolToSend);
    virtual unsigned int getNumSymbolsToSend() const;
    virtual void setNumSymbolsToSend(unsigned int numSymbolsToSend);
    virtual unsigned int getNumSymbolsToGet() const;
    virtual void setNumSymbolsToGet(unsigned int numSymbolsToGet);
    virtual unsigned int getFileId() const;
    virtual void setFileId(unsigned int fileId);
    virtual unsigned int getRequestSequenceNumber() const;
    virtual void setRequestSequenceNumber(unsigned int requestSequenceNumber);
    virtual unsigned int getSymbolSequenceNumber() const;
    virtual void setSymbolSequenceNumber(unsigned int symbolSequenceNumber);
    virtual unsigned int getOpcode() const;
    virtual void setOpcode(unsigned int opcode);
    virtual unsigned short getHeaderLength() const;
    virtual void setHeaderLength(unsigned short headerLength);
    virtual bool getUrgBit() const;
    virtual void setUrgBit(bool urgBit);
    virtual bool getAckBit() const;
    virtual void setAckBit(bool ackBit);
    virtual bool getPshBit() const;
    virtual void setPshBit(bool pshBit);
    virtual bool getRstBit() const;
    virtual void setRstBit(bool rstBit);
    virtual bool getSynBit() const;
    virtual void setSynBit(bool synBit);
    virtual bool getFinBit() const;
    virtual void setFinBit(bool finBit);
    virtual unsigned short getWindow() const;
    virtual void setWindow(unsigned short window);
    virtual unsigned short getUrgentPointer() const;
    virtual void setUrgentPointer(unsigned short urgentPointer);
    virtual void setHeaderOptionArraySize(unsigned int size) = 0;
    virtual unsigned int getHeaderOptionArraySize() const = 0;
    virtual RQOptionPtr& getHeaderOption(unsigned int k) = 0;
    virtual const RQOptionPtr& getHeaderOption(unsigned int k) const {return const_cast<RQSegment_Base*>(this)->getHeaderOption(k);}
    virtual void setHeaderOption(unsigned int k, const RQOptionPtr& headerOption) = 0;
    virtual unsigned long getPayloadLength() const;
    virtual void setPayloadLength(unsigned long payloadLength);
    virtual void setPayloadArraySize(unsigned int size) = 0;
    virtual unsigned int getPayloadArraySize() const = 0;
    virtual RQPayloadMessage& getPayload(unsigned int k) = 0;
    virtual const RQPayloadMessage& getPayload(unsigned int k) const {return const_cast<RQSegment_Base*>(this)->getPayload(k);}
    virtual void setPayload(unsigned int k, const RQPayloadMessage& payload) = 0;
    virtual ByteArray& getByteArray();
    virtual const ByteArray& getByteArray() const {return const_cast<RQSegment_Base*>(this)->getByteArray();}
    virtual void setByteArray(const ByteArray& byteArray);
};

} // namespace raptorq
} // namespace inet

#endif // ifndef __INET__RAPTORQ_RQSEGMENT_M_H

